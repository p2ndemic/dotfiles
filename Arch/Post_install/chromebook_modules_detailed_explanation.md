Хорошо, вот таблица с более сжатым, но информативным описанием для каждого файла:

| Модуль | Файл                       | Назначение                                                                                       | Функциональность                                                                                                                                                                            | Релевантность                      | Initramfs |
| :----- | :------------------------- | :----------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------- | :-------- |
|        | `cros_ec_keyb.c`           | Управляет клавиатурой, специальными кнопками и переключателями, подключенными через EC.            | Читает состояние матрицы клавиатуры и кнопок/переключателей из EC, применяет фильтр фантомных нажатий (опционально), генерирует события ввода Linux (`EV_KEY`, `EV_SW`), поддерживает раскладку Vivaldi. | Высокая                            |           |
|        | `cros_usbpd_notify.c`    | Централизованно обрабатывает и рассылает уведомления о событиях USB Power Delivery от EC.          | Получает события PD от EC (через ACPI или MKBP), запрашивает детальный статус (`EC_CMD_PD_HOST_EVENT_STATUS`), уведомляет подписчиков (другие драйверы).                                     | Высокая                            |           |
|        | `cros-ec-keyb.yaml`        | (Device Tree Binding) Описывает конфигурацию клавиатуры EC для систем, использующих Device Tree.     | Определяет `compatible`, размеры матрицы, keymap, необходимость фильтра фантомных нажатий, раскладку функционального ряда.                                                                   | Низкая (DTB), Средняя (док.)       |           |
|        | `extcon-usbc-cros-ec.c`  | Определяет состояние USB-C портов через EC и сообщает системе через фреймворк Extcon.             | Определяет подключение, роли (питание, данные), полярность, режим DP/SuperSpeed, HPD. Использует команды `EC_CMD_USB_PD_*`.                                                               | Высокая                            |           |
|        | `cros_usbpd-charger.c`   | Представляет USB-C и выделенные зарядные устройства (подключенные через EC) как источники питания Linux. | Запрашивает инфо о ЗУ (`EC_CMD_USB_PD_POWER_INFO` и др.), регистрирует `power_supply`, сообщает статус, тип USB, лимиты тока/напряжения. Позволяет задавать лимиты (`EC_CMD_EXTERNAL_POWER_LIMIT`).  | Высокая                            |           |
|        | `cros_typec_switch.c`    | Управляет мультиплексорами (mux) и ретаймерами USB-C портов через команды EC.                       | Отправляет команды EC (`EC_CMD_TYPEC_CONTROL`) для переключения порта в режим USB, DP, Safe Mode. Регистрирует устройства `typec_mux` и `typec_retimer`.                                       | Высокая                            |           |
|        | `cros_ec_hwmon.c`        | Предоставляет интерфейс hwmon для датчиков температуры и вентиляторов, управляемых EC.             | Читает данные из памяти EC (`EC_MEMMAP_*`), получает имена датчиков (`EC_CMD_TEMP_SENSOR_GET_INFO`), регистрирует `hwmon` устройство, сообщает температуру (mC), скорость (RPM), ошибки.     | Высокая                            |           |
|        | `gpio-cros-ec.c`         | Предоставляет интерфейс для управления GPIO линиями, контролируемыми EC.                             | Получает кол-во, имена, направления GPIO (`EC_CMD_GPIO_GET`), читает/пишет состояние (`EC_CMD_GPIO_GET`/`SET`), регистрирует `gpio_chip`. Запись возможна при разблокированной системе.           | Средняя/Высокая (система)        |           |
|        | `cros_ec_typec.c`        | Основной драйвер управления USB Type-C портами через EC.                                         | Регистрирует порты/партнеров/кабели/AltModes (DP, TBT) в Type-C фреймворке, обрабатывает PD discovery (`EC_CMD_TYPEC_DISCOVERY`), статус (`EC_CMD_TYPEC_STATUS`), VDM, координирует mux/retimer. | Очень высокая                      |           |
|        | `cros_ec_lpc.c`          | (Транспорт) Обеспечивает связь ядра с EC через шину LPC.                                         | Реализует низкоуровневую передачу команд/данных (`EC_CMD_*`) по LPC, чтение памяти EC, обработку прерываний/ACPI notify, поддерживает MEC EC, содержит квирки (Framework).                     | Высокая                            |           |
|        | `cros-ec-typec.yaml`     | (Device Tree Binding) Описывает узлы Type-C контроллера и коннекторов в Device Tree.              | Определяет `compatible` строку, структуру узлов-коннекторов и их свойства (ссылка на `usb-connector.yaml`).                                                                                  | Низкая (DTB), Средняя (док.)       |           |
|        | `cros_ec_dev.c`          | (MFD) Обнаруживает функции EC и создает платформенные устройства для под-драйверов.                | Запрашивает функции EC (`EC_CMD_GET_FEATURES`), создает дочерние устройства (`cros-ec-keyb`, `cros-usbpd-charger` и др.) для загрузки нужных драйверов, регистрирует класс `chromeos`.           | Очень высокая                      |           |
|        | `cros_ec_debugfs.c`      | Создает интерфейс отладки EC через debugfs.                                                      | Предоставляет доступ к логам консоли EC (опрос), информации о панике (`EC_CMD_GET_PANIC_INFO`), базовой инфо PD, uptime EC (`EC_CMD_GET_UPTIME_INFO`), результатам resume.                     | Средняя                            |           |
|        | `rtc-cros-ec.c`          | Реализует интерфейс RTC (часы реального времени), используя EC как источник.                      | Читает/пишет время (`EC_CMD_RTC_GET/SET_VALUE`), читает/пишет будильник (`EC_CMD_RTC_GET/SET_ALARM`), обрабатывает события будильника от EC, регистрирует `/dev/rtcX`.                        | Высокая                            |           |
|        | `cros_ec_chardev.h`      | (UAPI Header) Определяет структуры и ioctl для взаимодействия userspace с EC через `/dev/cros_ec`. | Определяет `struct cros_ec_command`, `struct cros_ec_readmem`, команды ioctl `CROS_EC_DEV_IOCXCMD`, `CROS_EC_DEV_IOCRDMEM`, `CROS_EC_DEV_IOCEVENTMASK`.                                        | Высокая (для userspace утилит)     |           |
|        | `cros_ec_sysfs.c`        | Экспортирует параметры и команды управления EC через sysfs.                                      | Предоставляет атрибуты sysfs для перезагрузки EC (`reboot`), просмотра версий (`version`), информации о flash (`flashinfo`), угла пробуждения клавиатуры (`kb_wake_angle`).                   | Средняя/Высокая                    |           |
|        | `cros_ec.c`              | (Ядро EC) Основная логика работы с EC, не зависящая от транспорта.                              | Содержит функции регистрации EC, отправки команд (`cros_ec_cmd_*`), запроса событий (`cros_ec_get_next_event`), проверки функций, обработки IRQ, suspend/resume (`cros_ec_sleep_event`).      | Очень высокая                      |           |
|        | `chromeos_laptop.c`      | (Устаревший/Квирки) Инстанцирует I2C-устройства на старых моделях Chromebook по DMI.            | Использует DMI для идентификации, создает I2C-клиентов (тачпады, сенсоры) на нужных адаптерах, обрабатывает неполные ACPI-описания.                                                      | Низкая/Нулевая (для вашей системы) |           |
|        | `chromeos_acpi.c`        | Обеспечивает доступ к специфичным для ChromeOS ACPI методам (на `GGL0001`/`GOOG0016`).           | Вызывает ACPI-методы (`FWID`, `HWID`, `VBNV`, `GPIO` и др.), экспортирует результаты через sysfs.                                                                                      | Средняя/Высокая                    |           |
|        | `cros_ec.h`              | (Header) Определяет структуру `cros_ec_device` и API ядра `cros_ec.c`.                             | Прототипы `cros_ec_register`/`unregister`, `suspend`/`resume` хелперов, обработчика IRQ.                                                                                                   | Высокая (для системы)              |           |
|        | `leds-cros_ec.c`         | Управляет светодиодами (LED), подключенными к EC, через подсистему `leds`.                         | Использует `EC_CMD_LED_CONTROL` для управления яркостью/цветом, регистрирует `led_classdev_mc`, поддерживает триггер `chromeos-auto`.                                                   | Средняя/Высокая                    |           |
|        | `cros_usbpd_notify.h`    | (Header) Определяет API для подписки на события USB Power Delivery (`cros_usbpd_notify.c`).        | Прототипы `cros_usbpd_register_notify`, `cros_usbpd_unregister_notify`.                                                                                                                     | Высокая (для системы)              |           |
|        | `cros_kbd_led_backlight.c` | Управляет подсветкой клавиатуры через EC PWM или ACPI.                                           | Использует ACPI (`GOOG0002`) или команды EC (`EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT`) для установки яркости, регистрирует LED устройство `chromeos::kbd_backlight`.                               | Высокая (если есть подсветка)      |           |
|        | `cros_ec_ucsi.c`         | Реализует стандартный интерфейс UCSI поверх протокола команд ChromeOS EC.                        | Транслирует команды UCSI в команды EC (`EC_CMD_UCSI_PPM_*`), обрабатывает уведомления от EC (`PD_EVENT_PPM`), регистрирует UCSI устройство.                                                 | Высокая                            |           |
|        | `cros_usbpd_logger.c`    | Периодически считывает и выводит в dmesg лог событий USB Power Delivery из EC.                   | Использует `EC_CMD_PD_GET_LOG_ENTRY` для чтения лога, форматирует и выводит записи. Полезен для отладки PD.                                                                                | Низкая/Средняя                     |           |
|        | `cros_ec_codec.c`        | (ALSA Codec) Драйвер для аудио-функций EC (цифровые микрофоны, Wake-on-Voice).                   | Регистрирует ALSA SoC компоненты/DAI, управляет усилением DMIC, загрузкой WoV моделей, чтением аудио WoV (`EC_CMD_EC_CODEC*`), использует shared memory (опционально).                          | Высокая                            |           |
|        | `cros_ec_typec.h`        | (Header) Определяет внутренние структуры данных для драйвера `cros_ec_typec.c`.                  | Структуры `cros_typec_data`, `cros_typec_port`, `cros_typec_altmode_node`.                                                                                                               | Высокая (для системы)              |           |
|        | `cros_charge-control.c`  | Реализует расширенный контроль зарядки (пороги, режимы) через EC.                                | Использует `EC_CMD_CHARGE_CONTROL`, добавляет свойства (`charge_control_*`, `charge_behaviour`) к устройству батареи через `power_supply_ext`.                                            | Средняя/Высокая                    |           |
|        | `cros_ec_chardev.c`      | Создает символьное устройство `/dev/cros_ec` для взаимодействия userspace с EC.                  | Реализует `ioctl` для отправки команд (`CROS_EC_DEV_IOCXCMD`), чтения памяти (`IOCRDMEM`), подписки на события MKBP (`IOCEVENTMASK`).                                                        | Высокая                            |           |
|        | `pwm-cros-ec.c`          | Управляет общими ШИМ (PWM) выходами EC, представляя их как стандартные PWM-устройства.          | Использует `EC_CMD_PWM_SET/GET_DUTY`, регистрирует `pwm_chip`, управляет PWM по индексу или типу (KB/Display light).                                                                        | Средняя/Низкая                     |           |
|        | `cros_peripheral_charger.c`| Представляет статус зарядки периферийных устройств (стилусов) через `power_supply`.             | Использует `EC_CMD_PCHG` для получения статуса/процента заряда периферии, регистрирует `power_supply` для каждого порта.                                                                  | Низкая/Нулевая (для вашей системы) |           |
|        | `extcon-usbc-cros-ec.yaml` | (Device Tree Binding) Описывает узел для драйвера `extcon-usbc-cros-ec.c`.                      | Определяет `compatible` строку и обязательное свойство `google,usb-port-id`.                                                                                                               | Низкая (DTB), Средняя (док.)       |           |
|        | `cros-ec-codec.yaml`     | (Device Tree Binding) Описывает узел для драйвера `cros_ec_codec.c`.                             | Определяет `compatible`, параметры DAI, опциональные регионы shared memory (`reg`, `memory-region`).                                                                                       | Низкая (DTB), Средняя (док.)       |           |

---

1.  **Файл:** `cros_ec_keyb.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Этот драйвер управляет клавиатурой и некоторыми специальными кнопками/переключателями (например, кнопка питания, громкость вверх/вниз, яркость вверх/вниз, блокировка экрана, переключатель крышки (lid switch), переключатель режима планшета) на устройствах ChromeOS, где эти компоненты подключены через Embedded Controller (EC).
    * **Ключевые функции/Особенности:**
        * Взаимодействует с EC по протоколу ChromeOS EC (через LPC, SPI или I2C) для получения состояния матрицы клавиатуры (какие клавиши нажаты).
        * Обрабатывает полученные данные сканирования матрицы.
        * Реализует программный фильтр "фантомных" нажатий (ghosting filter), если он необходим и включен (свойство `google,needs-ghost-filter` в Device Tree).
        * Преобразует состояние матрицы и события от кнопок/переключателей в стандартные события ввода Linux (Input subsystem events), такие как `EV_KEY` (нажатия клавиш) и `EV_SW` (события переключателей).
        * Использует команды EC, такие как `EC_CMD_MKBP_INFO` (для получения информации о поддерживаемых кнопках/переключателях) и получает события от EC (например, `EC_MKBP_EVENT_KEY_MATRIX`, `EC_MKBP_EVENT_BUTTON`, `EC_MKBP_EVENT_SWITCH`).
        * Поддерживает обработку специальных функциональных рядов клавиатуры (Vivaldi layout) через свойство `function-row-physmap` в Device Tree.
    * **Релевантность для вашей системы:** **Высокая**. Этот драйвер необходим для работы встроенной клавиатуры вашего Chromebook и, вероятно, специальных кнопок, если они управляются через EC.

2.  **Файл:** `cros_usbpd_notify.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Этот драйвер служит центральным приемником и диспетчером уведомлений о событиях USB Power Delivery (PD), поступающих от ChromeOS EC. Он позволяет другим драйверам (например, драйверу зарядки `cros_usbpd-charger` или драйверу Type-C `cros_ec_typec`) подписываться на эти события.
    * **Ключевые функции/Особенности:**
        * Регистрирует обработчик уведомлений ACPI (для устройства `GOOG0003`, если присутствует) или обработчик событий EC MKBP (Make/Break Protocol).
        * При получении уведомления от EC (связанного с PD или USB Mux), он запрашивает у EC актуальный статус хост-событий командой `EC_CMD_PD_HOST_EVENT_STATUS`.
        * Рассылает полученный статус (битовую маску событий) всем зарегистрированным подписчикам через стандартный механизм `blocking_notifier_call_chain`.
        * Предоставляет функции `cros_usbpd_register_notify` и `cros_usbpd_unregister_notify` для управления подписками.
    * **Релевантность для вашей системы:** **Высокая**. Необходим для корректной работы управления питанием через USB-C порты и их конфигурации.

3.  **Файл:** `cros-ec-keyb.yaml`
    * **Тип:** Файл привязки Device Tree (Device Tree Binding).
    * **Назначение:** Описывает, как представить клавиатуру ChromeOS EC в Device Tree для систем, использующих Device Tree (обычно не x86, но используется как документация и для проверки конфигурации). Для x86 систем конфигурация часто происходит через ACPI.
    * **Ключевые функции/Особенности:**
        * Определяет `compatible` строки: `google,cros-ec-keyb` (для клавиатуры и, возможно, кнопок) и `google,cros-ec-keyb-switches` (только для кнопок/переключателей).
        * Описывает стандартные свойства матричной клавиатуры (`keypad,num-rows`, `keypad,num-columns`, `linux,keymap`).
        * Описывает специфичные для Google свойства: `google,needs-ghost-filter` (логическое значение, включающее программный фильтр фантомных нажатий) и `function-row-physmap` (массив u32, описывающий физическое расположение клавиш верхнего ряда для нестандартных раскладок Vivaldi).
    * **Релевантность для вашей системы:** **Низкая (как DTB)**, так как у вас x86 система с ACPI/UEFI. Однако, **Высокая (как документация)**, так как описывает свойства, которые драйвер `cros_ec_keyb.c` ожидает и использует.

4.  **Файл:** `extcon-usbc-cros-ec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Этот драйвер использует ChromeOS EC для определения состояния USB-C портов и сообщает об этом системе через фреймворк External Connector (extcon). Он отслеживает подключение/отключение кабелей, роль порта по питанию (источник/потребитель), роль по данным (хост/устройство), ориентацию кабеля (полярность), активность DisplayPort (DP) и SuperSpeed (USB 3.x) линий.
    * **Ключевые функции/Особенности:**
        * Взаимодействует с EC с помощью команд `EC_CMD_USB_PD_POWER_INFO`, `EC_CMD_USB_PD_MUX_INFO`, `EC_CMD_USB_PD_CONTROL`, `EC_CMD_USB_PD_PORTS`.
        * Регистрирует `extcon_dev` для каждого USB-C порта, управляемого EC.
        * Определяет тип подключенного устройства (например, зарядное устройство, USB-устройство, DP-адаптер).
        * Устанавливает состояния extcon (`EXTCON_USB`, `EXTCON_USB_HOST`, `EXTCON_DISP_DP`) и свойства (`EXTCON_PROP_USB_VBUS`, `EXTCON_PROP_USB_TYPEC_POLARITY`, `EXTCON_PROP_USB_SS`, `EXTCON_PROP_DISP_HPD`).
        * Реагирует на события от EC (через `cros_ec_device->event_notifier`), указывающие на изменение состояния порта.
    * **Релевантность для вашей системы:** **Высокая**. Отвечает за базовое определение того, что подключено к вашим USB-C портам.

5.  **Файл:** `cros_usbpd-charger.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Представляет зарядные устройства, подключенные через USB-C порты (а также иногда выделенные зарядные порты), как источники питания в подсистеме `power_supply` ядра Linux.
    * **Ключевые функции/Особенности:**
        * Запрашивает у EC информацию о подключенных зарядных устройствах для каждого порта (`EC_CMD_USB_PD_POWER_INFO`, `EC_CMD_USB_PD_DISCOVERY`, `EC_CMD_CHARGE_PORT_COUNT`, `EC_CMD_USB_PD_PORTS`).
        * Регистрирует `power_supply` устройство для каждого активного зарядного порта (например, `CROS_USBPD_CHARGER0`, `CROS_DEDICATED_CHARGER`).
        * Предоставляет информацию через sysfs (`/sys/class/power_supply/...`), такую как статус (`online`, `status`), тип USB (`usb_type` - PD, DCP, SDP и т.д.), максимальный ток (`current_max`), максимальное напряжение (`voltage_max_design`), текущее напряжение (`voltage_now`), модель и производителя (если доступно через PD Discovery).
        * Реагирует на события изменения состояния питания (через `cros_usbpd_notify`), обновляя статус устройств.
        * Позволяет устанавливать общие для системы ограничения по току/напряжению (`input_current_limit`, `input_voltage_limit`) через команду `EC_CMD_EXTERNAL_POWER_LIMIT`.
    * **Релевантность для вашей системы:** **Высокая**. Отвечает за то, как система видит и взаимодействует с подключенными зарядными устройствами.

6.  **Файл:** `cros_typec_switch.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Управляет переключением режимов работы мультиплексоров (muxes) и ретаймеров (retimers) на USB-C портах через команды, отправляемые в EC. Используется для активации USB, DisplayPort или других альтернативных режимов.
    * **Ключевые функции/Особенности:**
        * Использует команду EC `EC_CMD_TYPEC_CONTROL` с подкомандами `TYPEC_CONTROL_COMMAND_USB_MUX_SET` для установки состояния мультиплексора/ретаймера и `TYPEC_CONTROL_COMMAND_CLEAR_EVENTS` для сброса флагов событий.
        * Использует команду EC `EC_CMD_TYPEC_STATUS` для проверки статуса операции переключения.
        * Регистрирует устройства `typec_mux_dev` и `typec_retimer` в подсистеме Type-C ядра.
        * Предоставляет колбэки (`cros_typec_mode_switch_set`, `cros_typec_retimer_set`), которые вызываются Type-C фреймворком для выполнения переключения.
        * EC рассматривает и мультиплексоры (индекс 0), и ретаймеры (индекс 1) как "мультиплексоры" с точки зрения API команд.
    * **Релевантность для вашей системы:** **Высокая**. Необходим для правильной работы альтернативных режимов (например, DisplayPort over USB-C) и высокоскоростной передачи данных через USB-C.

7.  **Файл:** `cros_ec_hwmon.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Предоставляет интерфейс аппаратного мониторинга (hwmon) для датчиков температуры и вентиляторов, управляемых через EC.
    * **Ключевые функции/Особенности:**
        * Читает значения температуры и скорости вентиляторов напрямую из областей памяти EC (`EC_MEMMAP_TEMP_SENSOR`, `EC_MEMMAP_TEMP_SENSOR_B`, `EC_MEMMAP_FAN`) с помощью функции `cros_ec_cmd_readmem`.
        * Для получения имен датчиков температуры использует команду `EC_CMD_TEMP_SENSOR_GET_INFO`.
        * Регистрирует устройство `hwmon`, которое создает файлы в sysfs (например, `/sys/class/hwmon/hwmonX/`).
        * Предоставляет значения температуры (в миллиградусах Цельсия) и скорости вентиляторов (в RPM).
        * Сообщает об ошибках датчиков (например, не подключен, ошибка чтения) через атрибуты `*_fault`.
    * **Релевантность для вашей системы:** **Высокая**. Позволяет системным утилитам и пользователю отслеживать температуру и скорость вращения вентиляторов. Ваша `inxi` показывает датчики `cpu` и `mobo`, этот драйвер может быть источником данных для `mobo` или других не указанных датчиков, если они читаются из EC.

8.  **Файл:** `gpio-cros-ec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Предоставляет интерфейс для управления линиями GPIO (General Purpose Input/Output), которые контролируются EC.
    * **Ключевые функции/Особенности:**
        * Использует команду EC `EC_CMD_GPIO_GET` (с подкомандами `EC_GPIO_GET_INFO`, `EC_GPIO_GET_COUNT`) для получения информации о количестве GPIO, их именах и текущем направлении (вход/выход).
        * Использует команду EC `EC_CMD_GPIO_GET` (без подкоманд) для чтения текущего состояния GPIO.
        * Использует команду EC `EC_CMD_GPIO_SET` для установки состояния GPIO (только если система "разблокирована" - т.е., не в режиме secure boot).
        * Регистрирует `gpio_chip` в подсистеме GPIO ядра Linux, позволяя использовать эти GPIO через стандартные интерфейсы ядра и sysfs.
        * Добавляет префикс "EC:" к именам GPIO, чтобы избежать конфликтов имен.
    * **Релевантность для вашей системы:** **Средняя/Низкая (для пользователя)**. Обычно эти GPIO используются для внутренних нужд системы или специфических аппаратных функций, редко требуя прямого вмешательства пользователя. Но для работы системы может быть **Высокая**.

9.  **Файл:** `cros_ec_typec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Является основным драйвером для управления и отображения состояния USB Type-C портов через ChromeOS EC. Он координирует работу других связанных модулей (extcon, switch, charger, VDM).
    * **Ключевые функции/Особенности:**
        * Определяет количество USB-C портов (`EC_CMD_USB_PD_PORTS`).
        * Парсит свойства порта из Device Tree или ACPI.
        * Регистрирует каждый порт в Type-C фреймворке ядра (`typec_register_port`).
        * Обнаруживает подключение/отключение партнеров и кабелей (`typec_register_partner`, `typec_register_cable`).
        * Запрашивает и обрабатывает информацию об идентификации PD (`EC_CMD_TYPEC_DISCOVERY` для SOP и SOP') и возможностях партнера (PDO).
        * Регистрирует альтернативные режимы (Alt Modes), такие как DisplayPort и Thunderbolt, как для порта, так и для партнера/кабеля (`typec_partner_register_altmode`, `cros_typec_register_displayport`, etc.).
        * Получает статус порта от EC (`EC_CMD_USB_PD_CONTROL`, `EC_CMD_TYPEC_STATUS`) и обновляет состояние в Type-C фреймворке.
        * Координирует переключение мультиплексоров/ретаймеров (`cros_typec_configure_mux`) на основе текущего режима работы порта (USB, DP, TBT, USB4).
        * Обрабатывает события от EC (через `cros_usbpd_notify`), такие как VDM ответы/внимание, завершение обнаружения, аппаратный сброс.
        * Включает обработку VDM (Vendor Defined Messages) через `cros_typec_vdm.h`.
    * **Релевантность для вашей системы:** **Очень высокая**. Это центральный драйвер для всей функциональности USB-C.

10. **Файл:** `cros_ec_lpc.c`
    * **Тип:** Исходный код драйвера ядра Linux (транспортный уровень).
    * **Назначение:** Обеспечивает связь между ядром Linux и ChromeOS EC через шину LPC (Low Pin Count). Это один из возможных способов связи (другие - SPI, I2C).
    * **Ключевые функции/Особенности:**
        * Реализует функции низкоуровневой передачи данных (`cros_ec_cmd_xfer_lpc`, `cros_ec_pkt_xfer_lpc`) для отправки команд и получения ответов/данных от EC через регистры ввода/вывода LPC.
        * Реализует чтение из областей памяти EC, отображаемых на LPC (`cros_ec_lpc_readmem`).
        * Поддерживает стандартный протокол команд ChromeOS EC (v2 и v3).
        * Обрабатывает прерывания от EC (если IRQ назначен).
        * Получает уведомления ACPI (например, `ACPI_NOTIFY_CROS_EC_PANIC`, `ACPI_NOTIFY_CROS_EC_MKBP`) от устройства `GOOG0004`.
        * Содержит обходные пути (quirks) для специфического оборудования, включая поддержку Microchip EC (MEC) и обработку ACPI Mutex (`CROS_EC_LPC_QUIRK_AML_MUTEX`) для синхронизации доступа к EC (актуально для Framework Laptop).
        * Регистрирует основное устройство `cros_ec_device`, которое затем используется другими драйверами.
    * **Релевантность для вашей системы:** **Высокая**. Вероятно, именно этот драйвер используется для связи с EC на вашем ноутбуке, так как LPC - частый интерфейс для EC на x86 платформах.

11. **Файл:** `cros-ec-typec.yaml`
    * **Тип:** Файл привязки Device Tree (Device Tree Binding).
    * **Назначение:** Описывает узел Type-C контроллера (`google,cros-ec-typec`) и его дочерние узлы-коннекторы в Device Tree.
    * **Ключевые функции/Особенности:**
        * Определяет `compatible` строку `google,cros-ec-typec`.
        * Указывает, что дочерние узлы-коннекторы используют один `reg` (номер порта) для адресации.
        * Ссылается на общую схему USB-коннектора (`/schemas/connector/usb-connector.yaml#`) для описания свойств каждого порта (например, `power-role`, `data-role`).
    * **Релевантность для вашей системы:** **Низкая (как DTB)**, так как у вас x86 ACPI система. **Средняя (как документация)** для понимания структуры узлов.

12. **Файл:** `cros_ec_dev.c`
    * **Тип:** Исходный код драйвера ядра Linux (MFD - Multi-Function Device).
    * **Назначение:** Это основной драйвер-диспетчер для ChromeOS EC. Он обнаруживает, какие функции поддерживаются конкретным EC, и создает платформенные устройства (platform devices) для соответствующих под-драйверов.
    * **Ключевые функции/Особенности:**
        * Привязывается к устройству, созданному транспортным драйвером (например, `cros_ec_lpc`).
        * Запрашивает у EC список поддерживаемых функций (`EC_CMD_GET_FEATURES`).
        * На основе ответа создает дочерние платформенные устройства с определенными именами (`cros-ec-cec`, `cros-ec-gpio`, `cros-ec-rtc`, `cros-usbpd-charger`, `cros-ec-sensorhub` и т.д.). Эти имена затем используются для загрузки соответствующих драйверов.
        * Создает "всегда присутствующие" устройства, такие как `cros-ec-chardev`, `cros-ec-debugfs`, `cros-ec-sysfs`, `cros-ec-hwmon`.
        * Регистрирует устройство класса `chromeos` (например, `/sys/class/chromeos/cros_ec`).
        * Различает основной EC (`cros_ec`) и контроллер PD (`cros_pd`), если они разделены.
    * **Релевантность для вашей системы:** **Очень высокая**. Этот драйвер является "корнем" для большинства других драйверов, взаимодействующих с EC.

13. **Файл:** `cros_ec_debugfs.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Предоставляет интерфейс отладки для ChromeOS EC через файловую систему debugfs (обычно монтируется в `/sys/kernel/debug`).
    * **Ключевые функции/Особенности:**
        * Создает директорию с именем EC (например, `/sys/kernel/debug/cros_ec`).
        * `console_log`: Файл для чтения консольного вывода EC. Драйвер периодически опрашивает EC (`EC_CMD_CONSOLE_SNAPSHOT`, `EC_CMD_CONSOLE_READ`) и помещает данные в кольцевой буфер в ядре, откуда их можно прочитать.
        * `panicinfo`: Файл (если EC предоставил данные о панике), содержащий информацию о последней панике EC (`EC_CMD_GET_PANIC_INFO`).
        * `pdinfo`: Файл для отображения базовой информации о состоянии USB PD портов (`EC_CMD_USB_PD_CONTROL`).
        * `uptime`: Файл, показывающий время работы EC с момента последней загрузки (`EC_CMD_GET_UPTIME_INFO`), если поддерживается.
        * `last_resume_result`: Показывает результат последнего выхода из сна.
        * `suspend_timeout_ms`: Позволяет читать/записывать таймаут ожидания EC при засыпании.
        * Регистрирует обработчик уведомлений о панике EC для немедленного сброса буферизированных логов.
    * **Релевантность для вашей системы:** **Средняя**. Полезен для отладки проблем, связанных с EC, но не требуется для нормальной работы.

14. **Файл:** `rtc-cros-ec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Реализует стандартный интерфейс часов реального времени (RTC), используя EC как источник времени и для установки будильников.
    * **Ключевые функции/Особенности:**
        * Использует команды EC `EC_CMD_RTC_GET_VALUE` и `EC_CMD_RTC_SET_VALUE` для чтения/записи текущего времени (в секундах с эпохи Unix).
        * Использует команды EC `EC_CMD_RTC_GET_ALARM` и `EC_CMD_RTC_SET_ALARM` для чтения/записи времени срабатывания будильника. Важно: EC работает с относительным временем будильника (через N секунд), а ядро Linux - с абсолютным, драйвер выполняет преобразование.
        * Регистрирует стандартное устройство RTC (`/dev/rtcX`).
        * Обрабатывает события от EC (`EC_HOST_EVENT_RTC`), сигнализируя ядру о срабатывании будильника (`rtc_update_irq`).
        * Поддерживает пробуждение системы по RTC-будильнику (`device_may_wakeup`).
    * **Релевантность для вашей системы:** **Высокая**. Обеспечивает работу системных часов и возможность пробуждения по времени.

15. **Файл:** `cros_ec_chardev.h`
    * **Тип:** Заголовочный файл ядра Linux (UAPI - Userspace API).
    * **Назначение:** Определяет структуры и константы для взаимодействия пользовательского пространства с EC через символьное устройство (создаваемое `cros_ec_chardev.c`).
    * **Ключевые функции/Особенности:**
        * `struct cros_ec_command`: Структура для отправки команд EC через ioctl. Включает номер команды, версию, размеры буферов ввода/вывода и поле для данных.
        * `struct cros_ec_readmem`: Структура для чтения областей памяти EC через ioctl. Включает смещение, количество байт и буфер.
        * Определения `ioctl` команд: `CROS_EC_DEV_IOCXCMD` (отправить команду), `CROS_EC_DEV_IOCRDMEM` (прочитать память), `CROS_EC_DEV_IOCEVENTMASK` (установить маску для получения событий MKBP через `read()`).
    * **Релевантность для вашей системы:** **Высокая**. Используется системными утилитами (например, `ectool`) для низкоуровневого взаимодействия с EC.

16. **Файл:** `cros_ec_sysfs.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Экспортирует различные параметры и команды управления EC через атрибуты sysfs в директории устройства класса `chromeos`.
    * **Ключевые функции/Особенности:**
        * `reboot`: Атрибут для управления перезагрузкой EC (например, переход в RO/RW прошивку, холодная перезагрузка). Запись строки типа "ro" или "cold" инициирует соответствующую команду `EC_CMD_REBOOT_EC`.
        * `version`: Атрибут только для чтения, отображает версии RO/RW прошивок EC, активный образ, информацию о сборке и чипе (`EC_CMD_GET_VERSION`, `EC_CMD_GET_BUILD_INFO`, `EC_CMD_GET_CHIP_INFO`, `EC_CMD_GET_BOARD_VERSION`).
        * `flashinfo`: Атрибут только для чтения, показывает информацию о флеш-памяти EC (размер, размеры блоков записи/стирания/защиты) (`EC_CMD_FLASH_INFO`).
        * `kb_wake_angle`: Атрибут для чтения/записи угла раскрытия крышки, при котором клавиатура пробуждается (если поддерживается датчиком движения в EC) (`EC_CMD_MOTION_SENSE_CMD` с подкомандой `MOTIONSENSE_CMD_KB_WAKE_ANGLE`).
    * **Релевантность для вашей системы:** **Средняя/Высокая**. Предоставляет удобный способ просмотра информации об EC и выполнения некоторых управляющих действий без специальных утилит.

17. **Файл:** `cros_ec.c`
    * **Тип:** Исходный код драйвера ядра Linux (ядро EC).
    * **Назначение:** Содержит основную логику для работы с ChromeOS EC, не зависящую от конкретного транспортного протокола (LPC, SPI, I2C).
    * **Ключевые функции/Особенности:**
        * `cros_ec_register`/`cros_ec_unregister`: Функции для регистрации/дерегистрации устройства EC, вызываемые транспортными драйверами.
        * `cros_ec_query_all`: Запрашивает базовую информацию у EC при инициализации (версии протокола, размеры буферов, поддерживаемые функции).
        * `cros_ec_cmd_xfer`/`cros_ec_cmd_xfer_status`: Основные функции для отправки команд EC и получения ответов, обрабатывающие версионирование протокола и базовую проверку ошибок.
        * `cros_ec_get_next_event`: Запрашивает следующее событие из очереди MKBP EC.
        * `cros_ec_check_features`: Проверяет, поддерживает ли EC определенную функцию.
        * `cros_ec_irq_handler`/`cros_ec_irq_thread`: Обработчики прерываний от EC (верхняя и нижняя половины) для обработки событий MKBP.
        * `cros_ec_sleep_event`: Отправляет команду EC о переходе хоста в/из состояния сна (`EC_CMD_HOST_SLEEP_EVENT`).
        * `cros_ec_suspend*`/`cros_ec_resume*`: Функции-помощники для обработки приостановки/возобновления работы системы, взаимодействующие с EC.
        * Управление мьютексом (`ec_dev->lock`) для синхронизации доступа к EC.
        * Управление цепочками уведомлений (`event_notifier`, `panic_notifier`).
    * **Релевантность для вашей системы:** **Очень высокая**. Это ядро взаимодействия с EC.

18. **Файл:** `chromeos_laptop.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Этот драйвер предназначен для автоматического создания (инстанцирования) I2C-устройств (таких как тачпады Atmel/Cypress/Elan, датчики освещенности ISL/TAOS) на некоторых моделях Chromebook, где информация ACPI может быть неполной или отсутствует. Он использует DMI (System Management BIOS) для идентификации модели ноутбука.
    * **Ключевые функции/Особенности:**
        * Содержит таблицы `dmi_system_id`, сопоставляющие DMI-идентификаторы конкретных моделей Chromebook (например, "Samsung Series 5 550", "Acer C720", "Chromebook Pixel") с наборами I2C-периферии, которую нужно создать.
        * Для каждого периферийного устройства указывается имя драйвера, I2C-адрес (основной и иногда альтернативный), тип I2C-адаптера, к которому оно подключено (например, SMBus, i915 GMBUS), и иногда IRQ (получаемый также через DMI).
        * Использует `i2c_new_scanned_device` или `i2c_new_client_device` для регистрации I2C-клиентов.
        * Устанавливает `notifier_block` для шины I2C, чтобы проверять новые адаптеры и клиенты и создавать/настраивать устройства по мере их появления.
        * Может добавлять свойства устройства через `software_node` для ACPI-устройств с неполной информацией (пример: тачпад/тачскрин Atmel на Samus/Caroline).
    * **Релевантность для вашей системы:** **Низкая/Нулевая**. Этот драйвер, скорее всего, не активен на вашей системе. Ваш ноутбук (Acer Chromebook 516 GE / Osiris) является относительно новым, и ожидается, что его ACPI-таблицы достаточно полны для автоматического обнаружения I2C-устройств стандартными средствами ACPI/ядра. Этот драйвер больше актуален для старых моделей или специфических случаев.

19. **Файл:** `chromeos_acpi.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Обеспечивает доступ к специфичным для ChromeOS методам ACPI, предоставляемым устройством с ACPI HID `GGL0001` или `GOOG0016`. Экспортирует полученные значения через sysfs.
    * **Ключевые функции/Особенности:**
        * Привязывается к ACPI-устройству `GGL0001` или `GOOG0016`.
        * Вызывает ACPI-методы с именами, соответствующими атрибутам sysfs (например, `BINF`, `CHSW`, `FMAP`, `FRID`, `FWID`, `HWID`, `MECK`, `VBNV`, `VDAT`, `GPIO`).
        * Методы могут возвращать целые числа, строки, буферы или пакеты (массивы) данных. Драйвер форматирует их для отображения в sysfs.
        * Для метода `GPIO`, который может возвращать пакет пакетов, создаются поддиректории `GPIO.0`, `GPIO.1` и т.д., и внутри них атрибуты `GPIO.0`, `GPIO.1`, ... для доступа к отдельным элементам.
        * Создает атрибуты и группы атрибутов в sysfs для представления данных ACPI.
    * **Релевантность для вашей системы:** **Средняя/Высокая**. Эти ACPI-методы часто содержат важную информацию об идентификаторах платформы, версии прошивки, состоянии переключателей и т.д., которая может использоваться системными утилитами.

20. **Файл:** `cros_ec.h`
    * **Тип:** Заголовочный файл ядра Linux.
    * **Назначение:** Определяет основную структуру `cros_ec_device` и экспортирует функции ядра `cros_ec.c` для использования транспортными драйверами (LPC, SPI, I2C) и другими модулями, взаимодействующими с EC.
    * **Ключевые функции/Особенности:**
        * Прототипы функций `cros_ec_register`, `cros_ec_unregister`.
        * Прототипы функций-помощников для suspend/resume (`cros_ec_suspend*`, `cros_ec_resume*`).
        * Прототип потокового обработчика прерываний `cros_ec_irq_thread`.
    * **Релевантность для вашей системы:** **Высокая (для системы)**. Это ключевой заголовочный файл для сборки модулей EC.

21. **Файл:** `leds-cros_ec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Управляет светодиодами (LED), подключенными к ChromeOS EC, и регистрирует их в подсистеме `leds` ядра Linux.
    * **Ключевые функции/Особенности:**
        * Использует команду EC `EC_CMD_LED_CONTROL` для запроса информации о светодиодах и управления их яркостью.
        * Поддерживает многоцветные светодиоды, регистрируя их как `led_classdev_mc`.
        * Сопоставляет идентификаторы цветов EC (`EC_LED_COLOR_*`) с идентификаторами цветов Linux (`LED_COLOR_ID_*`).
        * Сопоставляет идентификаторы LED EC (`EC_LED_ID_*`) с функциональными именами Linux (`LED_FUNCTION_*` или кастомными).
        * Регистрирует триггер `chromeos-auto`, который передает управление светодиодом обратно EC (используя флаг `EC_LED_FLAGS_AUTO`). Этот триггер часто используется по умолчанию.
    * **Релевантность для вашей системы:** **Средняя/Высокая**. Если на вашем ноутбуке есть светодиоды состояния (питание, зарядка), управляемые EC, этот драйвер отвечает за их интеграцию с Linux.

22. **Файл:** `cros_usbpd_notify.h`
    * **Тип:** Заголовочный файл ядра Linux.
    * **Назначение:** Определяет публичный API (функции `cros_usbpd_register_notify` и `cros_usbpd_unregister_notify`) для драйвера `cros_usbpd_notify.c`. Позволяет другим модулям ядра подписываться на уведомления о событиях USB Power Delivery.
    * **Ключевые функции/Особенности:**
        * Прототипы функций для регистрации и отмены регистрации `notifier_block`.
    * **Релевантность для вашей системы:** **Высокая (для системы)**. Необходим для сборки модулей, зависящих от уведомлений PD (например, `cros_ec_typec`, `cros_usbpd-charger`).

23. **Файл:** `cros_kbd_led_backlight.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Управляет подсветкой клавиатуры.
    * **Ключевые функции/Особенности:**
        * Может работать двумя способами:
            * Через ACPI: Взаимодействует с ACPI-устройством `\\_SB.KBLT` (обычно с HID `GOOG0002`), вызывая методы `.KBQC` (получить яркость) и `.KBCM` (установить яркость).
            * Через EC PWM: Использует команды EC `EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT` и `EC_CMD_PWM_GET_KEYBOARD_BACKLIGHT` для управления яркостью (в процентах). Этот режим используется, когда драйвер загружается как дочернее устройство `cros-ec-dev` (MFD).
        * Регистрирует стандартное устройство класса LED (`led_classdev`) с именем `chromeos::kbd_backlight` в sysfs (`/sys/class/leds/`).
        * Максимальная яркость обычно устанавливается в 100.
    * **Релевантность для вашей системы:** **Высокая**, если у вашего ноутбука есть подсветка клавиатуры.

24. **Файл:** `cros_ec_ucsi.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Реализует стандартный интерфейс UCSI (USB-C Connector System Software Interface) поверх протокола команд ChromeOS EC. Это позволяет использовать стандартный стек UCSI ядра Linux для управления USB-C портами, даже если прямого UCSI-контроллера нет, а его функции выполняет EC.
    * **Ключевые функции/Особенности:**
        * Регистрирует UCSI-устройство (`ucsi_create`, `ucsi_register`).
        * Реализует операции UCSI (`ucsi_operations`):
            * Чтение регистров UCSI (`UCSI_VERSION`, `UCSI_CCI`, `UCSI_MESSAGE_IN`) путем отправки команды EC `EC_CMD_UCSI_PPM_GET`.
            * Отправка команд UCSI (`UCSI_CONTROL`) путем отправки команды EC `EC_CMD_UCSI_PPM_SET`.
        * Использует `cros_usbpd_notify` для получения уведомлений от EC о событиях UCSI (`PD_EVENT_PPM`).
        * Обрабатывает события и уведомляет UCSI-фреймворк ядра (`ucsi_notify_common`).
        * Реализует логику обработки таймаутов и занятости PPM (Policy Manager).
    * **Релевантность для вашей системы:** **Высокая**. Современные системы часто используют UCSI для управления Type-C/PD, и если эту роль выполняет EC, то этот драйвер необходим.

25. **Файл:** `cros_usbpd_logger.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Периодически считывает журнал событий USB Power Delivery из EC и выводит его в системный лог ядра (dmesg).
    * **Ключевые функции/Особенности:**
        * Использует команду EC `EC_CMD_PD_GET_LOG_ENTRY` для получения записей лога по одной.
        * Запускает отложенную рабочую задачу (`delayed_work`), которая выполняется раз в `CROS_USBPD_LOG_UPDATE_DELAY` (по умолчанию 60 секунд).
        * Форматирует полученные записи лога (тип события, временная метка, порт, данные) и выводит их с помощью `pr_info`.
        * Обрабатывает различные типы событий (изменение состояния зарядки, ошибки, события видеорежимов и т.д.).
    * **Релевантность для вашей системы:** **Низкая/Средняя**. Полезен для отладки проблем с USB Power Delivery, но не критичен для основной функциональности.

26. **Файл:** `cros_ec_codec.c`
    * **Тип:** Исходный код драйвера ядра Linux (ALSA SoC Codec).
    * **Назначение:** Реализует драйвер кодека ALSA SoC для аудио-функций, предоставляемых ChromeOS EC. В основном это касается цифровых микрофонов (DMIC) и функциональности Wake-on-Voice (WoV).
    * **Ключевые функции/Особенности:**
        * Регистрирует компоненты ALSA SoC (`snd_soc_component_driver`) и DAI (`snd_soc_dai_driver`) для I2S RX (прием данных с DMIC) и WoV.
        * Взаимодействует с EC с помощью команд `EC_CMD_EC_CODEC`, `EC_CMD_EC_CODEC_I2S_RX`, `EC_CMD_EC_CODEC_WOV`.
        * Для I2S RX: управляет форматом данных, частотой дискретизации, разрядностью, соотношением BCLK, включает/выключает интерфейс.
        * Для DMIC: предоставляет элемент управления ALSA (`snd_kcontrol`) для регулировки усиления микрофонов (`EC Mic Gain`).
        * Для WoV:
            * Управляет включением/выключением WoV (`EC_CODEC_WOV_ENABLE`/`DISABLE`).
            * Загружает модель распознавания ключевых слов (`EC_CODEC_WOV_SET_LANG` или `EC_CODEC_WOV_SET_LANG_SHM`).
            * Считывает аудиоданные при обнаружении ключевого слова (`EC_CODEC_WOV_READ_AUDIO` или `EC_CODEC_WOV_READ_AUDIO_SHM`).
            * Использует shared memory (если поддерживается EC) для обмена данными модели и аудио.
            * Регистрирует PCM устройство для захвата аудио WoV.
            * Обрабатывает события от EC (`EC_HOST_EVENT_WOV`).
    * **Релевантность для вашей системы:** **Высокая**. Судя по `inxi`, у вас аудиоконтроллер Intel с драйвером `sof-audio-pci-intel-tgl`. Этот драйвер (`cros_ec_codec`) может быть частью аудио-пайплайна, отвечая за обработку сигнала с цифровых микрофонов, которые физически подключены к EC.

27. **Файл:** `cros_ec_typec.h`
    * **Тип:** Заголовочный файл ядра Linux.
    * **Назначение:** Определяет внутренние структуры данных, используемые драйвером `cros_ec_typec.c` и, возможно, его подмодулями (например, VDM, altmode).
    * **Ключевые функции/Особенности:**
        * `struct cros_typec_data`: Глобальная структура данных драйвера (указатель на EC, количество портов, массив портов и т.д.).
        * `struct cros_typec_port`: Структура данных для каждого отдельного Type-C порта (указатели на `typec_port`, `partner`, `cable`, `mux`, `retimer`, `role_switch`, идентификаторы PD, состояние и т.д.).
        * `struct cros_typec_altmode_node`: Структура для связных списков альтернативных режимов.
        * `enum { CROS_EC_ALTMODE_DP, CROS_EC_ALTMODE_TBT, ... }`: Перечисление для внутренних индексов поддерживаемых альтернативных режимов.
    * **Релевантность для вашей системы:** **Высокая (для системы)**. Необходим для сборки модуля `cros_ec_typec`.

28. **Файл:** `cros_charge-control.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Предоставляет расширенный контроль над процессом зарядки аккумулятора через EC, позволяя устанавливать пороги начала/окончания зарядки и режимы поведения (авто, не заряжать, принудительно разряжать).
    * **Ключевые функции/Особенности:**
        * Использует команду EC `EC_CMD_CHARGE_CONTROL` для установки режима (`CHARGE_CONTROL_NORMAL`, `CHARGE_CONTROL_IDLE`, `CHARGE_CONTROL_DISCHARGE`) и порогов (`sustain_soc.lower`, `sustain_soc.upper`).
        * Определяет поддерживаемую версию команды EC (v1, v2, v3), от которой зависит доступность управления порогами.
        * Регистрирует расширение (`power_supply_ext`) для существующих устройств батарей (`power_supply`), найденных через ACPI (`acpi_battery_hook`).
        * Добавляет свойства `charge_control_start_threshold`, `charge_control_end_threshold`, `charge_behaviour` в sysfs для подключенной батареи.
        * Кэширует текущие настройки в драйвере, так как EC API не всегда позволяет их читать. Синхронизация с EC происходит при изменении `charge_behaviour`.
        * Содержит проверку для избежания конфликта с кастомной командой управления зарядом на ноутбуках Framework (если не указан параметр модуля `probe_with_fwk_charge_control`).
    * **Релевантность для вашей системы:** **Средняя/Высокая**. Позволяет реализовать функции продления срока службы батареи путем ограничения максимального уровня заряда.

29. **Файл:** `cros_ec_chardev.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Создает символьное устройство (`/dev/cros_ec` или `/dev/cros_pd` и т.д.) для каждого экземпляра EC, обнаруженного в системе. Это устройство предоставляет интерфейс `ioctl` для взаимодействия с EC из пользовательского пространства.
    * **Ключевые функции/Особенности:**
        * Регистрирует "misc" устройство (`misc_register`).
        * Реализует файловые операции (`file_operations`):
            * `open`/`release`: Выделение/освобождение приватных данных для каждого открытого файла, регистрация/дерегистрация `notifier_block` для событий MKBP.
            * `read`: Чтение данных. Если установлен `event_mask` (через ioctl), читает события MKBP из очереди. В противном случае (для обратной совместимости) возвращает строку с версией EC.
            * `poll`: Позволяет ожидать появления событий MKBP в очереди.
            * `unlocked_ioctl`: Обрабатывает ioctl-команды (`CROS_EC_DEV_IOCXCMD`, `CROS_EC_DEV_IOCRDMEM`, `CROS_EC_DEV_IOCEVENTMASK`).
        * `CROS_EC_DEV_IOCXCMD`: Принимает `struct cros_ec_command` от пользователя, отправляет команду в EC (используя `cros_ec_cmd_xfer`) и возвращает результат.
        * `CROS_EC_DEV_IOCRDMEM`: Принимает `struct cros_ec_readmem`, читает указанную область памяти EC (используя `ec_dev->cmd_readmem`) и возвращает данные.
        * `CROS_EC_DEV_IOCEVENTMASK`: Устанавливает маску событий MKBP, которые будут помещаться в очередь для чтения через `read()`.
    * **Релевантность для вашей системы:** **Высокая**. Это стандартный способ для утилит типа `ectool` взаимодействовать с EC.

30. **Файл:** `pwm-cros-ec.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Управляет ШИМ (PWM) выходами, контролируемыми EC, и представляет их как стандартные PWM-устройства в Linux.
    * **Ключевые функции/Особенности:**
        * Регистрирует `pwm_chip` в подсистеме PWM ядра.
        * Использует команды EC `EC_CMD_PWM_SET_DUTY` и `EC_CMD_PWM_GET_DUTY` для установки и получения коэффициента заполнения (duty cycle) PWM.
        * Может работать в двух режимах:
            * Индексированные каналы: Управляет PWM по числовому индексу (0, 1, 2...). Количество каналов определяется путем опроса до получения ошибки `INVALID_PARAM`.
            * Типизированные каналы (если `compatible = "google,cros-ec-pwm-type"`): Управляет PWM по типу (`EC_PWM_TYPE_KB_LIGHT`, `EC_PWM_TYPE_DISPLAY_LIGHT`).
        * Период PWM предполагается фиксированным и равным `EC_PWM_MAX_DUTY` (обычно 100 или 256, зависит от EC). Полярность всегда нормальная.
        * Включение/выключение PWM реализуется установкой duty cycle > 0 или = 0.
    * **Релевантность для вашей системы:** **Средняя/Низкая**. Если подсветка клавиатуры или экрана управляется через специфичные команды (как в `cros_kbd_led_backlight.c` или драйвере `i915`), то этот общий PWM драйвер может не использоваться. Но если есть другие PWM-управляемые компоненты, подключенные к EC, он может быть активен.

31. **Файл:** `cros_peripheral_charger.c`
    * **Тип:** Исходный код драйвера ядра Linux.
    * **Назначение:** Представляет статус зарядки для периферийных устройств (например, стилусов), которые заряжаются при подключении/установке в Chromebook, через интерфейс `power_supply`.
    * **Ключевые функции/Особенности:**
        * Определяет количество портов для зарядки периферии (`EC_CMD_PCHG_COUNT`).
        * Для каждого порта регистрирует устройство `power_supply` (например, `/sys/class/power_supply/peripheral0`).
        * Периодически или по событию от EC (`EC_MKBP_EVENT_PCHG`) запрашивает статус порта командой `EC_CMD_PCHG`.
        * Предоставляет свойства: `status` (unknown, charging, full), `capacity` (процент заряда периферийного устройства), `charge_type` (none, trickle, standard).
        * Использует версию 1 протокола команды `EC_CMD_PCHG`.
    * **Релевантность для вашей системы:** **Низкая/Нулевая**, если у вашего ноутбука нет док-станции или специального отсека для зарядки периферийных устройств типа стилуса.

32. **Файл:** `extcon-usbc-cros-ec.yaml`
    * **Тип:** Файл привязки Device Tree (Device Tree Binding).
    * **Назначение:** Описывает узел для драйвера `extcon-usbc-cros-ec.c` в Device Tree.
    * **Ключевые функции/Особенности:**
        * Определяет `compatible` строку `google,extcon-usbc-cros-ec`.
        * Требует свойство `google,usb-port-id` (u32) для указания номера порта, к которому относится этот узел `extcon`.
    * **Релевантность для вашей системы:** **Низкая (как DTB)**, **Средняя (как документация)**. Показывает, как порт идентифицируется.

33. **Файл:** `cros-ec-codec.yaml`
    * **Тип:** Файл привязки Device Tree (Device Tree Binding).
    * **Назначение:** Описывает узел для драйвера `cros_ec_codec.c` в Device Tree.
    * **Ключевые функции/Особенности:**
        * Определяет `compatible` строку `google,cros-ec-codec`.
        * `#sound-dai-cells = <1>`: Указывает, что для идентификации DAI-линка используется один параметр (индекс).
        * `reg`: Описывает регион памяти EC, используемый кодеком (если применимо).
        * `memory-region`: Ссылка на зарезервированный регион памяти в ОЗУ системы, используемый для shared memory с EC.
    * **Релевантность для вашей системы:** **Низкая (как DTB)**, **Средняя (как документация)**. Описывает возможные параметры конфигурации кодека.

---
